from pwn import *
import os
from Crypto.Cipher import AES

os.environ["PWNLIB_NOTERM"] = "True"
os.environ["PWNLIB_SILENT"] = "True"

HOST = "130.192.5.212"
PORT = 6531

BLOCK_SIZE = AES.block_size
BLOCK_SIZE_HEX = 2 * BLOCK_SIZE

server = remote(HOST, PORT)

for i in range(128):
    print(server.recvline().decode())  # "Challenge #i"

    # Get OTP line and parse it
    otp_line = server.recvline().decode()
    otp_hex = otp_line.strip().split()[-1]
    otp = bytes.fromhex(otp_hex)
    assert len(otp) == 32

    # Known plaintext (two identical blocks)
    known_plaintext = b"B" * 16 + b"B" * 16
    data_to_send = bytes([a ^ b for a, b in zip(known_plaintext, otp)])

    server.sendlineafter(b"Input: ", data_to_send.hex().encode())

    ciphertext_line = server.recvline().decode()
    ciphertext_hex = ciphertext_line.strip().split()[-1]
    ciphertext_bytes = bytes.fromhex(ciphertext_hex)

    # Detect ECB by checking if first two blocks are identical
    if ciphertext_bytes[:16] == ciphertext_bytes[16:32]:
        mode = "ECB"
    else:
        mode = "CBC"

    print(f"[+] Detected mode: {mode}")
    server.sendlineafter(b'What mode did I use? (ECB, CBC)\n', mode.encode())

    response = server.recvline()
    print(response.decode())
    if b"Wrong" in response:
        print("[!] Failed at round", i)
        break

# Get the flag if successful
final_response = server.recvall()
print(final_response.decode())

server.close()
