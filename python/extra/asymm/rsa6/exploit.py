from pwn import *
from Crypto.Util.number import long_to_bytes, inverse

HOST = "130.192.5.212"
PORT = 6646
e = 65537

# Connessione al server
r = remote(HOST, PORT)

# Step 1: prendi il ciphertext della flag
ciphertext = int(r.recvline().strip())
print(f"Ciphertext: {ciphertext}")

# Step 2: scegli s
s = 3

# Step 3: chiedi l'encryption di s → ricevi s^e mod n
r.sendline(f"e{s}".encode())
se = int(r.recvline().strip())
print(f"s^e mod n = {se}")

# Step 4: calcola c' = (ciphertext * s^e) mod n
# anche se non conosci n, puoi moltiplicare e mandare il risultato:
c_prime = (ciphertext * se)

# Step 5: chiedi la decryption di c' al server
r.sendline(f"d{c_prime}".encode())
dec = int(r.recvline().strip())

# Step 6: calcola s^{-1} mod n ⇒ serve n!
# Ma puoi **ricavarlo** ora: se = s^e mod n ⇒ quindi se ≡ s^e (mod n)
# n = gcd(s^e - se, c_prime - m')

# Ma più semplicemente, visto che ora hai (m * s) = dec mod n,
# puoi ancora ricostruire m = dec * s^{-1} mod n
# Usa n = se - s^e mod se (stima) oppure:

# Calcola n = gcd(s^e - se, ciphertext * s^e - c_prime)
from math import gcd
s_e = pow(s, e)
n = gcd(s_e - se, ciphertext * s_e - c_prime)

# print(f"n = {n}")
s_inv = inverse(s, n)
m = (dec * s_inv) % n

flag = long_to_bytes(m)
print(f"Flag: {flag.decode()}")
