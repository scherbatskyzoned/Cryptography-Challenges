from pwn import *
import string

HOST = "130.192.5.212"
PORT = 6544
BLOCK_SIZE = 16



def find_padding1_len(conn):
    for possible_len in range(6, 0, -1):
        known_len = 2 * BLOCK_SIZE + (BLOCK_SIZE - possible_len)
        known = b"A" * known_len
        conn.sendlineafter("> ", b'enc')
        conn.sendlineafter("> ", known.hex().encode())
        out = conn.recvline().strip()
        ct = bytes.fromhex(out.decode())


        blocks = [ct[i:i + BLOCK_SIZE] for i in range(0, len(ct), BLOCK_SIZE)]
        if blocks[1] == blocks[2]:
            # print(f"[+] Found padding1 length: {possible_len}")
            return possible_len

conn = remote(HOST, PORT)
padding1_len = find_padding1_len(conn)
padding2_len = 10 - padding1_len
print(f"[+] Padding1 length: {padding1_len}, Padding2 length: {padding2_len}")

# PPPPPPAAAAAAAAAA
# AAPPPPCRYPTO25{_
# 
# CRYPTO25{.......
# G


conn.close()

# # Charset alfanumerico + simboli usabili
# charset = (
#     string.ascii_letters + string.digits +
#     "{}_-!@#$%^&*().,<>?=+~:;[]|/\\"
# )

# def split_blocks(data: bytes, block_size: int = 16):
#     return [data[i:i + block_size] for i in range(0, len(data), block_size)]

# def get_ciphertext(io, data: bytes) -> bytes:
#     io.sendlineafter("> ", b'enc')
#     io.sendlineafter("> ", data.hex().encode())
#     out = io.recvline().strip()
#     return bytes.fromhex(out.decode())


# def save_flag(flag):
#     with open("flag.txt", "w") as f:
#         f.write(flag)

# def leak_flag():
#     known = b"CRYPTO25{"

#     while True:
#         io = remote(HOST, PORT)
#         prefix_pad_len = find_padding1_len(io)
#         if prefix_pad_len is None:
#             print("[-] Allineamento fallito, riprovo...")
#             io.close()
#             continue

#         print(f"[+] Prefix pad length: {prefix_pad_len}")

#         while True:
#             # Calcolo del padding per allineare il prossimo byte della flag in fondo a un blocco
#             pad_len = BLOCK_SIZE - ((len(known) + 1) % BLOCK_SIZE)
#             payload_base = b'A' * prefix_pad_len + b'B' * pad_len

#             # Calcolo del blocco che conterr√† il prossimo carattere della flag
#             target_block_index = (prefix_pad_len + pad_len + len(known)) // BLOCK_SIZE

#             try:
#                 ref_ct = get_ciphertext(io, payload_base + known)
#             except Exception as e:
#                 print(f"[-] Errore durante la richiesta di riferimento: {e}")
#                 break

#             ref_blocks = split_blocks(ref_ct)
#             found = False

#             for c in charset:
#                 attempt = payload_base + known + c.encode()
#                 try:
#                     test_ct = get_ciphertext(io, attempt)
#                 except:
#                     break

#                 test_blocks = split_blocks(test_ct)

#                 if test_blocks[target_block_index] == ref_blocks[target_block_index]:
#                     known += c.encode()
#                     print(f"[+] Found: {known.decode()}")
#                     save_flag(known.decode())
#                     found = True
#                     break

#             if not found:
#                 print("[!] Nessuna corrispondenza, cambio sessione...")
#                 break

#             if known.endswith(b'}'):
#                 print(f"[+] FLAG COMPLETA: {known.decode()}")
#                 io.close()
#                 return known.decode()

#         io.close()

# if __name__ == "__main__":
#     flag = leak_flag()
#     print(f"[FINAL FLAG]: {flag}")
