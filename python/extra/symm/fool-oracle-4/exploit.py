from pwn import *
import string

HOST = "130.192.5.212"
PORT = 6544
BLOCK_SIZE = 16

charset = (
    string.ascii_letters + string.digits +
    "{}_-!@#$%^&*().,<>?=+~:;[]|/\\"
)

def find_padding1_len(conn):
    for possible_len in range(6, 0, -1):
        known_len = 2 * BLOCK_SIZE + (BLOCK_SIZE - possible_len)
        known = b"A" * known_len
        conn.sendlineafter(b"> ", b'enc')
        conn.sendlineafter(b"> ", known.hex().encode())
        out = conn.recvline().strip()
        ct = bytes.fromhex(out.decode())


        blocks = [ct[i:i + BLOCK_SIZE] for i in range(0, len(ct), BLOCK_SIZE)]
        if blocks[1] == blocks[2]:
            # print(f"[+] Found padding1 length: {possible_len}")
            return possible_len


def split_blocks(data: bytes, block_size: int = 16):
    return [data[i:i + block_size] for i in range(0, len(data), block_size)]

def split_blocks_hex(hex_str: str, block_size: int = 16) -> list[str]:
    """
    Splits a hex string into blocks of 2 * block_size characters.
    """
    return [hex_str[i:i + 2 * block_size] for i in range(0, len(hex_str), 2 * block_size)]


def get_ciphertext_hex(conn, data):
    conn.sendlineafter(b"> ", b'enc')
    conn.sendlineafter(b"> ", data)
    out = conn.recvline().strip()
    return out.decode()

def guess_padding2_hex(conn, pad1_len): # [4,9] bytes => [8, 18] hex values
    pad2_len = 10 - pad1_len

    known_first = "41" * (BLOCK_SIZE - pad1_len)
    # print(f"[+] Known first block: {known_first}")
    # print("[+] First block: ", "Ph"*pad1_len, known_first, sep="")

    paddin2_value = b"".hex()
    guessed_len = 0
    # find padding2 value
    while guessed_len < pad2_len:
        for i in range(1,256):
            guessed_value = f"{i:02x}"
            prefix_second = "41" * (BLOCK_SIZE - guessed_len - 1)
            second_block = prefix_second + paddin2_value + guessed_value  + prefix_second
            
            ct_hex = get_ciphertext_hex(conn, (known_first + second_block).encode())
            blocks = split_blocks_hex(ct_hex)

            if blocks[1] == blocks[2]:
                print(f"[+] Found padding2 value: {guessed_value}")
                paddin2_value += guessed_value
                guessed_len += 1
                break
    
    print(f"[+] Padding2 value: {paddin2_value}")
    return paddin2_value


def connect_until_pad2_is_four():
    try:
        while True:
            conn = remote(HOST, PORT)
            pad1_len = find_padding1_len(conn)
            pad2_len = 10 - pad1_len
            if pad2_len == 4:
                # print(f"[+] Found connection with padding2 length: {pad2_len}")
                break
            else:
                conn.close()
    except Exception as e:
        print(f"[!] Connection failed: {e}")
        exit(1)
    return conn, pad1_len


def find_match(idx, blocks):
    to_check = blocks[idx]
    for i in range(idx + 1, len(blocks)):
        if blocks[i] == to_check:
            return True
    return False


def leak_flag(conn, pad1_len):
    known_flag = b"CRYPTO25{df0b0f03-0bd4-4dc8-9043-bcdac301684c"
    pad2_len = 10 - pad1_len 
    print(f"[+] Padding1 length: {pad1_len} Padding2 length: {pad2_len}")
    known_padding2 = guess_padding2_hex(conn, pad1_len)

    i = 1
    while len(known_flag) < 36+10:
        print(f"[+] Known flag: {known_flag.decode()}")
        p1 = "A" * (10 + 3*BLOCK_SIZE-i-5-5-6-8) # started when first 3 char where df0
        p2 = "B" * (4*BLOCK_SIZE-i-5-5-6-8) # 
        i += 1
        print(f"[+] Payload: {p1.encode().hex() + known_padding2 + known_flag.hex() + p2.encode().hex()}")
        idx = 4
        print(f"[+] Trying to find match for block @ idx: {idx}")
        
        '''
        # PPPPPPPPPPPP41414141414141414141
        # 41414141414141414141414141414141
        # 41414141414141a19ebf8f4352595054
        # 4f32357b64663062306630332d306264
        # 342d346463382d393034332d626364__
        # 42424242424242424242424242424242
        # 42424242424242424242424242424242
        # 42424242424242


        # PPPPPPAAAAAAAAAA
        # AAAAAAAAAAAAAAAA
        # AAAAAAAPPPPCRYPT
        # O25{df0b0f03-0bd
        # 4-4dc8-9043-bcd_
        # BBBBBBBBBBBBBBBB
        # BBBBBBBPPPPCRYPT
        # O25{df0b0f03-0bd
        # 4-4dc8-9043-bcd*



        # PPPPPPAAAAAAAAAA
        # AAAAAAAAAAAAAAAA
        # AAAAAAAAAAAAAAAA
        # AAAAAAAAAAPPPPCR
        # YPTO25{df0b0f03_
        # BBBBBBBBBBBBBBBB
        # BBBBBBBBBBBBBBBB
        # BBBBBBBBBBBBBBBB
        # BBBBBBBBBBPPPPCR
        # YPTO25{df0b0f03_
        # ......

        # PPPPPPAAAAAAAAAA
        # AAAAAAAAAAAAAAAA
        # AAAAAAAAAAAAAAAA
        # AAAAAAAAAAAAAAAP
        # PPPCRYPTO25{df0_
        # BBBBBBBBBBBBBBBB
        # BBBBBBBBBBBBBBBB
        # BBBBBBBBBBBBBBBP
        # PPPCRYPTO25{df0*
        # ......

        # PPPPPPAAAAAAAAAA
        # AAAAAAAAAAAAAAAA
        # AAAAAAAAAAAAAAAA
        # AAAAAPPPPCRYPTO2
        # 5{df0b0f03-0bd4_
        # BBBBBBBBBBBBBBBB
        # BBBBBBBBBBBBBBBB
        # BBBBBPPPPCRYPTO2
        # 5{df0b0f03-0bd4*

        '''
        

        for char in charset:
            payload = (p1.encode().hex() + known_padding2 + (known_flag + char.encode() + p2.encode()).hex()).encode()

            try:
                conn.sendlineafter(b"> ", b'enc')
                conn.sendlineafter(b"> ", payload)
                ct_hex = conn.recvline().strip().decode()
                blocks = split_blocks_hex(ct_hex)

                if find_match(idx, blocks):
                    print(f"[+] Found flag character: {char}")
                    known_flag += char.encode()
                    print(f"[+] Known flag so far: {known_flag.decode()}")
                    break
            except EOFError:
                print("[!] Connection closed unexpectedly.")
                exit(1)


def main():
    conn, pad1_len = connect_until_pad2_is_four()

    leak_flag(conn, pad1_len)

    conn.close()




main()


