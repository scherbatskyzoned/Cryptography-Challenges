from pwn import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from string import hexdigits

'''
# PPPPPPPPPPPPPPPA
# bbbbbbbCRYPTO25{
# bbbbbbbCRYPTO25{
# ________________
# ____
'''

HOST = "130.192.5.212"
PORT = 6543

possible_chars = '-' + hexdigits + '}'

server = remote(HOST, PORT)

flag = b"CRYPTO25{"

possible_paddings = []
# Get Effective Padding
for pad_value in range(1, 16):
    always_padding = b"A" * pad_value
    other_padding = b"b" * (AES.block_size - len(flag))
    data = always_padding + other_padding + flag + other_padding
    
    server.sendlineafter(b"> ", b"enc")
    server.sendlineafter(b"> ", data.hex().encode())

    ct = bytes.fromhex(server.recvline().decode().strip())
    # create array of blocks of dim = 16
    blocks = []
    for j in range(len(ct) // AES.block_size):
        blocks.append(ct[j*AES.block_size:(j+1)*AES.block_size]) # 0-16, 16-32, ...

    for value in blocks:
        if blocks.count(value) != 1:
            print(f"Eff padding could be: {pad_value}")
            possible_paddings.append(pad_value)


# flag_edt = flag
# Get first block
# while True:
#     flag = flag_edt
#     if (len(flag) >= 16):
#         break
#     for char_to_try in possible_chars:
#         flag_edt = flag + char_to_try.encode()
#         always_padding = b"A" * i
#         other_padding = b"A" * (AES.block_size - len(flag_edt))
#         pt = always_padding + other_padding + flag_edt + other_padding
#         print(f"trying {flag_edt}")
#         server.sendlineafter(b"> ", "enc".encode())
#         server.sendlineafter(b"> ", pt.hex().encode())

#         ct_hex = server.recvline().strip().decode()
#         ct_bytes = bytes.fromhex(ct_hex)
#         # 2nd and 3rd
#         if (ct_bytes[AES.block_size:2*AES.block_size] == ct_bytes[2*AES.block_size:3*AES.block_size]):
#             print(f"correct char: {char_to_try}")
#             break

# print(f"First block: {flag_edt}")

# PPPPPPPPPPPPPPPA
# RYPTO25{e3ab216*
# bbbbbbbbbbbbbbbC
# RYPTO25{e3ab216_
# ____

flag = "CRYPTO25{e3ab216" # 9 is next value

# 
## Get 2nd block
# found = 0
# i = 1
# while True:
#     if (len(flag) >= 32):
#         break
#     for char_to_try in possible_chars:
#         flag_edt = flag[i:] + char_to_try
#         assert(len(flag_edt) == 16)
#         always_padding = b"A" * pad_value
#         other_padding = b"b" * (AES.block_size - i)
#         pt = always_padding + flag_edt.encode() + other_padding
#         print(f"trying {flag_edt}")
#         server.sendlineafter(b"> ", "enc".encode())
#         server.sendlineafter(b"> ", pt.hex().encode())

#         ct_hex = server.recvline().strip().decode()
#         ct_bytes = bytes.fromhex(ct_hex)
#         # 2nd and 4th
#         if (ct_bytes[AES.block_size:2*AES.block_size] == ct_bytes[3*AES.block_size:4*AES.block_size]):
#             print(f"correct char: {char_to_try}")
#             i+=1
#             flag += char_to_try
#             found = 1
#             break
#     if not found:
#         print("not found")
#         exit(1)

# print(f"Second block: {flag_edt}")
# print(f"Flag until now: {flag}")

# Get 3rd block
flag = "CRYPTO25{e3ab2169-39d5-43aa-bde7"

found = 0
i = 1
pos = 0
while True:
    if (len(flag) >= 46):
        break
    for char_to_try in possible_chars:
        flag_edt = flag[AES.block_size+i:] + char_to_try
        assert(len(flag_edt) == 16)
        always_padding = b"A" * possible_paddings[pos]
        other_padding = b"b" * (AES.block_size - i)
        pt = always_padding + flag_edt.encode() + other_padding
        print(f"trying {flag_edt}")
        server.sendlineafter(b"> ", "enc".encode())
        server.sendlineafter(b"> ", pt.hex().encode())

        ct_hex = server.recvline().strip().decode()
        ct_bytes = bytes.fromhex(ct_hex)
        # 2nd and 5th
        if (ct_bytes[AES.block_size:2*AES.block_size] == ct_bytes[4*AES.block_size:5*AES.block_size]):
            print(f"correct char: {char_to_try}")
            i+=1
            flag += char_to_try
            found = 1
            break
    if not found:
        print("not found")
        pos += 1
        exit(1)

print(f"Second block: {flag_edt}")
print(f"Flag until now: {flag}")

server.close()







